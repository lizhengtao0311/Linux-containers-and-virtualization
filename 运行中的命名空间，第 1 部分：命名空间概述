原作参考链接：https://lwn.net/Articles/531114/

作者：Michael Kerrisk
2013 年 1 月 4 日
Linux 3.8 合并窗口见证了 Eric Biederman 大量用户命名空间和相关补丁的接受。尽管还有一些细节需要完成——例如，许多 Linux 文件系统还不知道用户命名空间——用户命名空间的实现现在在功能上已经完成。

出于多种原因，用户命名空间工作的完成是一个里程碑。首先，这项工作代表了迄今为止最复杂的命名空间实现之一的完成，事实证明，自实现用户命名空间（在 Linux 2.6.23 中）的第一步以来已经过去了大约五年。其次，命名空间工作目前处于某种“稳定点”，大多数现有命名空间的实现或多或少是完整的。这并不意味着命名空间的工作已经完成：未来可能会添加其他命名空间，并且可能会对现有命名空间进行进一步扩展，例如为内核日志添加命名空间隔离. 最后，最近用户命名空间实现的变化在命名空间的使用方式方面改变了游戏规则：从 Linux 3.8 开始，非特权进程可以创建他们拥有完全权限的用户命名空间，这反过来又允许任何其他要在用户命名空间内创建的命名空间类型。

因此，当前似乎是对命名空间进行概述并实际查看命名空间 API 的好时机。这是这样做的系列文章中的第一篇：在本文中，我们概述了当前可用的命名空间；在后续文章中，我们将展示如何在程序中使用命名空间 API。

命名空间
目前，Linux 实现了六种不同类型的命名空间。每个命名空间的目的是将特定的全局系统资源包装在一个抽象中，使命名空间内的进程看起来他们拥有自己的全局资源的隔离实例。命名空间的总体目标之一是支持容器的实现，容器是一种用于轻量级虚拟化（以及其他目的）的工具，它为一组进程提供了它们是系统上唯一进程的错觉。

在下面的讨论中，我们按照命名空间的实现顺序（或者至少是实现的完成顺序）来呈现命名空间。括号中列出的CLONE_NEW*标识符是在使用我们将在后续文章中描述的命名空间相关 API（clone()、unshare()和setns()）时用于标识命名空间类型的常量的名称。

挂载命名空间（CLONE_NEWNS，Linux 2.4.19）隔离一组进程看到的文件系统挂载点集。因此，不同挂载命名空间中的进程可以具有不同的文件系统层次结构视图。随着挂载命名空间的添加，mount() 和umount() 系统调用停止对系统上所有进程可见的全局挂载点集进行操作，而是执行仅影响与调用进程关联的挂载命名空间的操作。

挂载命名空间的一种用途是创建类似于 chroot jails 的环境。但是，与使用chroot()系统调用相比，挂载命名空间是完成此任务的更安全和灵活的工具。挂载命名空间的其他更复杂的使用也是可能的。例如，可以在主从关系中设置单独的挂载命名空间，使挂载事件自动从一个命名空间传播到另一个命名空间；例如，这允许安装在一个命名空间中的光盘设备自动出现在其他命名空间中。

挂载命名空间是第一种在 Linux 上实现的命名空间类型，出现在 2002 年。这一事实解释了相当通用的“NEWNS”绰号（“新命名空间”的缩写）：当时似乎没有人认为其他，将来可能需要不同类型的命名空间。

UTS 命名空间（CLONE_NEWUTS，Linux 2.6.19）隔离了两个系统标识符——节点名和 域名——由uname() 系统调用返回；名称是使用sethostname()和 setdomainname()系统调用设置的。在容器上下文中，UTS 命名空间功能允许每个容器拥有自己的主机名和 NIS 域名。这对于根据这些名称定制其操作的初始化和配置脚本很有用。术语“UTS”源自传递给uname()系统调用的结构名称 ：struct utsname. 该结构的名称又源自“UNIX 分时系统”。

IPC 命名空间（CLONE_NEWIPC，Linux 2.6.19）隔离某些进程间通信（IPC）资源，即System V IPC对象和（自 Linux 2.6.30 起）POSIX 消息队列。这些 IPC 机制的共同特征是 IPC 对象由文件系统路径名以外的机制标识。每个 IPC 命名空间都有自己的一组 System V IPC 标识符和自己的 POSIX 消息队列文件系统。

PID 命名空间（CLONE_NEWPID，Linux 2.6.24）隔离进程 ID 号空间。换句话说，不同 PID 命名空间中的进程可以具有相同的 PID。PID 命名空间的主要好处之一是容器可以在主机之间迁移，同时为容器内的进程保留相同的进程 ID。PID 命名空间还允许每个容器拥有自己的 init (PID 1)，即“所有进程的祖先”，管理各种系统初始化任务并在它们终止时收割孤立的子进程。

从特定 PID 命名空间实例的角度来看，一个进程有两个 PID：命名空间内的 PID 和主机系统命名空间外的 PID。PID 命名空间可以嵌套：从它所在的 PID 命名空间到根 PID 命名空间，一个进程将为层次结构的每一层都有一个 PID。进程只能看到（例如，通过/proc/ PID查看并使用kill()发送信号）包含在其自己的 PID 命名空间和嵌套在该 PID 命名空间下方的命名空间中的进程。

网络命名空间 （CLONE_NEWNET，从 Linux 2.4.19 2.6.24开始并在 Linux 2.6.29 左右完成）提供了与网络相关的系统资源的隔离。因此，每个网络命名空间都有自己的网络设备、IP 地址、IP 路由表、/proc/net目录、端口号等。

从网络的角度来看，网络命名空间使容器变得有用：每个容器都可以拥有自己的（虚拟）网络设备和自己的应用程序，这些应用程序绑定到每个命名空间的端口号空间；主机系统中合适的路由规则可以将网络数据包定向到与特定容器相关联的网络设备。因此，例如，可以在同一主机系统上拥有多个容器化 Web 服务器，每个服务器都绑定到其（每个容器）网络命名空间中的端口 80。

用户命名空间 （CLONE_NEWUSER，从 Linux 2.6.23 开始并在 Linux 3.8 中完成）隔离用户和组 ID 号空间。换句话说，进程的用户 ID 和组 ID 在用户命名空间内外可以不同。这里最有趣的情况是，一个进程可以在用户命名空间外拥有一个普通的非特权用户 ID，同时在命名空间内拥有一个用户 ID 0。这意味着该进程对用户命名空间内的操作具有完全的 root 权限，但对命名空间外的操作没有特权。

从 Linux 3.8 开始，无特权的进程可以创建用户命名空间，这为应用程序开辟了大量有趣的新可能性：由于原本没有特权的进程可以在用户命名空间内拥有 root 特权，无特权的应用程序现在可以访问以前仅限于的功能根。Eric Biederman 在使用户命名空间实现安全和正确方面付出了很多努力。然而，这项工作带来的变化是微妙而广泛的。因此，可能会发生用户命名空间存在一些未知的安全问题，这些问题在未来仍有待发现和修复。

结束语
距第一个 Linux 命名空间的实现已经过去了大约十年。从那时起，命名空间概念已扩展为一个更通用的框架，用于隔离范围以前是系统范围的一系列全局资源。因此，命名空间现在以容器的形式为完整的轻量级虚拟化系统提供了基础。随着命名空间概念的扩展，相关的 API 已经从单个系统调用 ( clone() ) 和一两个/proc 文件增长到包含许多其他系统调用和/proc下的更多文件。该 API 的详细信息将成为本文后续内容的主题。

系列索引
以下列表显示了本系列后面的文章及其示例程序：

第 2 部分：命名空间 API
demo_uts_namespaces.c：演示 UTS 命名空间的使用
ns_exec.c : 使用setns()加入命名空间并执行命令
unshare.c：取消共享命名空间并执行命令；在概念上类似于unshare(1)
第 3 部分：PID 命名空间
pidns_init_sleep.c : 演示 PID 命名空间
multi_pidns.c : 在嵌套的 PID 命名空间中创建一系列子进程
第 4 部分：有关 PID 名称空间的更多信息
ns_child_exec.c：创建一个在新命名空间中执行 shell 命令的子进程
simple_init.c：一个简单的 init(1)风格的程序，用作PID 命名空间中的init程序
orphan.c : 证明一个孩子成为孤儿并在其父退出时被init进程 收养
ns_run.c：使用setns()加入一个或多个命名空间并在这些命名空间中执行命令，可能在子进程中；在概念上类似于 nsenter(1)
第 5 部分：用户命名空间
demo_userns.c：创建用户命名空间并显示进程凭据和功能的简单程序
userns_child_exec.c：创建一个在新命名空间中执行 shell 命令的子进程；类似于 ns_child_exec.c，但具有用于用户命名空间的附加选项
第 6 部分：更多关于用户命名空间
userns_setns_test.c：从两个不同的用户命名空间测试setns()的操作。
第 7 部分：网络命名空间
挂载命名空间和共享子树
挂载命名空间、挂载传播和不可绑定挂载
