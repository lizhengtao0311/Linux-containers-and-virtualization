第1章
虚拟化基础
本书解释了虚拟化的基础知识，将有助于您可以创建自己的容器框架，类似于 Docker，但是为简约版。在我们开始这个旅程之前，我们需要了解 Linux 内核如何支持虚拟化以及 Linux 内核和 CPU 的演变如何提供帮助在性能方面促进虚拟机，这在反过来导致了容器化技术的创建。
本章的目的是解释什么是虚拟机和其神秘面纱下正在发生的事情。我们还研究hypervisors的一些基础知识，它是在系统中运行虚拟机基础。

虚拟化的历史
在虚拟化时代之前，获得完整物理服务器的唯一途径是通过 IT 提供。这是一个昂贵且耗时的过程。这种方法的主要缺点之一是机器的资源——像 CPU、内存和磁盘一样，仍未得到充分利用。为此，虚拟化的概念开始受到关注。
虚拟化的历史可以追溯到 1960 年代，当时 Jim Rymarczyk 是 IBM 的一名程序员，他开始虚拟化 IBM大型机。IBM 设计了 CP-40 大型机供内部使用。这个系统演变成CP-67，采用分区技术运行一次多个应用程序。最终出现了 UNIX，它允许多个
应用程序同时在 x86 硬件上运行。还是便携性问题留下了。上世纪 90 年代初，Sun Microsystems 提出了 Java，允许“一次编写，随处运行”范式展开。一种用户现在可以用 Java 编写一个程序，该程序可以运行在各种硬件架构。Java 通过引入中间代码做到了这一点（称为字节码），然后可以通过 Java 运行时在不同的硬件架构上运行。这是进程级的虚拟化，即 Java 运行时环境虚拟化了POSIX 层。
1990 年代后期，VMware 介入并推出了自己的虚拟化模型。这与虚拟化实际硬件有关，如 CPU、内存、磁盘等。这意味着在VMware 软件（也称为hypervisor），我们可以运行操作系统本身（称为guests OS）。这意味着开发人员没有仅限于运行 Java 程序，但可以在跟guest OS上运行任何软件进程。2001 年左右，VMware 推出了ESX 和 GSX 服务器。GSX 是type-2虚拟机管理程序，因此它需要一个像 Windows 这样的操作系统来运行guest OS。ESX 是一种type-1 hypervisor，它允许guest OS直接在Hypervisor上运行。

什么是虚拟化？
虚拟化在我们想要的实际资源之上提供抽象虚拟化。在这个抽象层上屏蔽了其他不同虚拟化技术实现。
在更高的层次上，在抽象层基础上有两种主要的虚拟化技术。
• 基于虚拟机 (VM)
• 基于容器

除了这两种虚拟化技术，还有其他技术，例如unikernels，它们是轻量级的单用途虚拟机。IBM 目前正尝试将 unikernels 作为项目的进程运行比如Nabla。在本书中，我们将主要关注基于 VM 和容器的虚拟化技术。

基于 VM 的虚拟化
基于 VM 的方法虚拟化整个操作系统。抽象层提供给 VM 的是虚拟设备，如虚拟磁盘、虚拟 CPU、和虚拟网卡。换句话说，我们可以说这是虚拟化完整的 ISA（指令集架构）；举个例子，x86 ISA。
通过虚拟机，多个操作系统可以共享相同的硬件资源，每个资源的虚拟化表示可用于 VM。例如，虚拟机上的操作系统（也称为guest OS）可以继续在磁盘上进行 I/O 操作（在此情况下，它是一个虚拟磁盘），认为它是唯一运行在物理硬件（也称为Host），虽然实际上它是由多个虚拟机以及主机操作系统共享。
VM 与主机操作系统中的其他进程非常相似。相比于主机操作系统，虚拟机执行在硬件隔离的虚拟地址空间和拥有较低的特权级别。进程和VM的主要区别在于Host暴露给VM的ABI（Application Binary Interface）。在进程的情况下，公开的 ABI 具有结构像网络套接字、FD 等，而对于成熟的操作系统虚拟化，ABI 将有一个虚拟磁盘、一个虚拟 CPU、虚拟网卡等等。

基于容器的虚拟化
这种形式的虚拟化并不抽象硬件，而是使用Linux 内核中隔离不同访问路径的技术资源。它在同一个操作中划出一个逻辑边界系统。例如，我们得到一个单独的根文件系统，一个单独的进程树、单独的网络子系统等。

Hypervisor
一种特殊的软件用于虚拟化操作系统，称为hypervisor。hypervisor本身有两个部分：
•虚拟机监视器 (VMM)：用于捕获并模拟特权指令集（其中只有操作系统的内核才能执行）。
•设备模型：用于虚拟化I/O 设备。

虚拟机监视器 (VMM)
由于硬件不能直接在虚拟机上使用（虽然在某些情况下可能是），VMM 会捕获访问权硬件（如磁盘/网卡）的特权指令并在代表虚拟机执行这些指令。
VMM 必须满足三个属性（Popek 和 Goldberg，1973）：
•隔离：应该将guest (VM) 彼此隔离。
•等效性：有或没有虚拟化应该表现相同。这意味着我们直接执行大多数物理硬件上的指令没有任何翻译动作，等等。

•性能：应该表现得和没有任何虚拟化一样好。这再次意味着运行虚拟机的开销很小。
VMM 的一些常见功能如下：
• 不允许VM 访问特权状态；诸如不应该允许来自VM的activity去操作Host寄存器的状态。VMM将始终捕获并模拟这些调用。
• 处理异常和中断。如果一个网络呼叫（即请求）是从虚拟内部发出的，它将被VMM截获并被模拟。通过物理网卡收到响应时，CPU 会产生一个中断并传递给实际虚拟机。
• 在VM里的虚拟CPU执行大多数的原生指令，针对特殊的少部分的特权指令要进行截获和模拟。这意味着性能几乎一样与直接在硬件上运行的效率一样好。
• 通过将调用映射到以下对象来处理内存映射 I/O来宾中的虚拟设备映射内存到实际的物理设备映射内存。为此，该VMM 应该控制物理内存映射（GuestOS物理内存到HostOS物理内存）。
更多细节将在本文后面的部分章节中介绍。

设备模型
hypervisor的设备模型通过捕获和模拟方式处理 I/O 虚拟化，然后将中断传递回给特定的虚拟机。

内存虚拟化
虚拟化的关键挑战之一是如何虚拟化内存。Guest OS应与非Guest OS具有相同的行为。这意味着Guest OS至少是感觉起来在管控着内存。
在虚拟化的情况下，Guest OS不能直接访问物理内存。这意味着Guest OS不能管理物理内存页表，如果不这样的话，那么guest OS就可以直接管理底层硬件系统。
在我们深入研究如何解决这个问题之前，对需要内存虚拟化基础应该有必要的了解，甚至要对一般操作系统跟底层硬件的交互也应有所了解。
操作系统为其进程提供内存的虚拟视图；任何访问物理内存的行为都将被一个称为内存管理单元 (MMU) 的组件中断和拦截处理。操作系统对CR3 寄存器进行设置（通过特权指令），之后 MMU 通过此寄存器条目信息遍历页表以确定物理内存映射。操作系统也在allocation和deallocation物理内存时，负责进行更改这些映射的操作。
Guest OS不应该直接访问物理内存，请求应该由 VMM 拦截和处理。

